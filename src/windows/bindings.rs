/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const NO_ERROR: u32 = 0;
pub const AF_UNSPEC: u32 = 0;
pub type ULONG = ::std::os::raw::c_ulong;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type WINBOOL = ::std::os::raw::c_int;
pub type BYTE = ::std::os::raw::c_uchar;
pub type DWORD = ::std::os::raw::c_ulong;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type ULONG64 = ::std::os::raw::c_ulonglong;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type LONG = ::std::os::raw::c_long;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type BOOLEAN = BYTE;
extern "stdcall" {
    pub fn GetCurrentThreadId() -> DWORD;
}
extern "stdcall" {
    pub fn SleepEx(dwMilliseconds: DWORD, bAlertable: WINBOOL) -> DWORD;
}
pub type NTSTATUS = LONG;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_long = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_addr {
    pub S_un: in_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in_addr__bindgen_ty_1 {
    pub S_un_b: in_addr__bindgen_ty_1__bindgen_ty_1,
    pub S_un_w: in_addr__bindgen_ty_1__bindgen_ty_2,
    pub S_addr: u_long,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct in_addr__bindgen_ty_1__bindgen_ty_1 {
    pub s_b1: u_char,
    pub s_b2: u_char,
    pub s_b3: u_char,
    pub s_b4: u_char,
}
#[test]
fn bindgen_test_layout_in_addr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in_addr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(in_addr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_1>())).s_b1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(s_b1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_1>())).s_b2 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(s_b2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_1>())).s_b3 as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(s_b3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_1>())).s_b4 as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(s_b4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct in_addr__bindgen_ty_1__bindgen_ty_2 {
    pub s_w1: u_short,
    pub s_w2: u_short,
}
#[test]
fn bindgen_test_layout_in_addr__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<in_addr__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(in_addr__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_2>())).s_w1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(s_w1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_2>())).s_w2 as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(s_w2)
        )
    );
}
#[test]
fn bindgen_test_layout_in_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in_addr__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr__bindgen_ty_1>())).S_un_b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr__bindgen_ty_1),
            "::",
            stringify!(S_un_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr__bindgen_ty_1>())).S_un_w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr__bindgen_ty_1),
            "::",
            stringify!(S_un_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr__bindgen_ty_1>())).S_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr__bindgen_ty_1),
            "::",
            stringify!(S_addr)
        )
    );
}
impl ::std::fmt::Debug for in_addr__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "in_addr__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).S_un as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(S_un)
        )
    );
}
impl ::std::fmt::Debug for in_addr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "in_addr {{ S_un: {:?} }}", self.S_un)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: ::std::os::raw::c_short,
    pub sin_port: u_short,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
impl ::std::fmt::Debug for sockaddr_in {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "sockaddr_in {{ sin_family: {:?}, sin_port: {:?}, sin_addr: {:?}, sin_zero: {:?} }}",
            self.sin_family, self.sin_port, self.sin_addr, self.sin_zero
        )
    }
}
pub type SOCKADDR_IN = sockaddr_in;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCOPE_ID {
    pub __bindgen_anon_1: _SCOPE_ID__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SCOPE_ID__bindgen_ty_1 {
    pub __bindgen_anon_1: _SCOPE_ID__bindgen_ty_1__bindgen_ty_1,
    pub Value: ULONG,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SCOPE_ID__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__SCOPE_ID__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_SCOPE_ID__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_SCOPE_ID__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SCOPE_ID__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SCOPE_ID__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _SCOPE_ID__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Zone(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Zone(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn Level(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Level(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Zone: ULONG, Level: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let Zone: u32 = unsafe { ::std::mem::transmute(Zone) };
            Zone as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let Level: u32 = unsafe { ::std::mem::transmute(Level) };
            Level as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__SCOPE_ID__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_SCOPE_ID__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_SCOPE_ID__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCOPE_ID__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_SCOPE_ID__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCOPE_ID__bindgen_ty_1>())).Value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_ID__bindgen_ty_1),
            "::",
            stringify!(Value)
        )
    );
}
impl ::std::fmt::Debug for _SCOPE_ID__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_SCOPE_ID__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout__SCOPE_ID() {
    assert_eq!(
        ::std::mem::size_of::<_SCOPE_ID>(),
        4usize,
        concat!("Size of: ", stringify!(_SCOPE_ID))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCOPE_ID>(),
        4usize,
        concat!("Alignment of ", stringify!(_SCOPE_ID))
    );
}
impl ::std::fmt::Debug for _SCOPE_ID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_SCOPE_ID {{ __bindgen_anon_1: {:?} }}",
            self.__bindgen_anon_1
        )
    }
}
pub type SCOPE_ID = _SCOPE_ID;
pub type ADDRESS_FAMILY = u_short;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub Byte: [u_char; 16usize],
    pub Word: [u_short; 8usize],
    _bindgen_union_align: [u16; 8usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).Byte as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(Byte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).Word as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(Word)
        )
    );
}
impl ::std::fmt::Debug for in6_addr__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "in6_addr__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        2usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(u)
        )
    );
}
impl ::std::fmt::Debug for in6_addr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "in6_addr {{ u: {:?} }}", self.u)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: ::std::os::raw::c_short,
    pub sin6_port: u_short,
    pub sin6_flowinfo: u_long,
    pub sin6_addr: in6_addr,
    pub __bindgen_anon_1: sockaddr_in6__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sockaddr_in6__bindgen_ty_1 {
    pub sin6_scope_id: u_long,
    pub sin6_scope_struct: SCOPE_ID,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(sockaddr_in6__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sockaddr_in6__bindgen_ty_1>())).sin6_scope_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6__bindgen_ty_1),
            "::",
            stringify!(sin6_scope_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sockaddr_in6__bindgen_ty_1>())).sin6_scope_struct as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6__bindgen_ty_1),
            "::",
            stringify!(sin6_scope_struct)
        )
    );
}
impl ::std::fmt::Debug for sockaddr_in6__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "sockaddr_in6__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
}
impl ::std::fmt::Debug for sockaddr_in6 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "sockaddr_in6 {{ sin6_family: {:?}, sin6_port: {:?}, sin6_flowinfo: {:?}, sin6_addr: {:?}, __bindgen_anon_1: {:?} }}" , self . sin6_family , self . sin6_port , self . sin6_flowinfo , self . sin6_addr , self . __bindgen_anon_1 )
    }
}
pub type SOCKADDR_IN6 = sockaddr_in6;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SOCKADDR_INET {
    pub Ipv4: SOCKADDR_IN,
    pub Ipv6: SOCKADDR_IN6,
    pub si_family: ADDRESS_FAMILY,
    _bindgen_union_align: [u32; 7usize],
}
#[test]
fn bindgen_test_layout__SOCKADDR_INET() {
    assert_eq!(
        ::std::mem::size_of::<_SOCKADDR_INET>(),
        28usize,
        concat!("Size of: ", stringify!(_SOCKADDR_INET))
    );
    assert_eq!(
        ::std::mem::align_of::<_SOCKADDR_INET>(),
        4usize,
        concat!("Alignment of ", stringify!(_SOCKADDR_INET))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SOCKADDR_INET>())).Ipv4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SOCKADDR_INET),
            "::",
            stringify!(Ipv4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SOCKADDR_INET>())).Ipv6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SOCKADDR_INET),
            "::",
            stringify!(Ipv6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SOCKADDR_INET>())).si_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SOCKADDR_INET),
            "::",
            stringify!(si_family)
        )
    );
}
impl ::std::fmt::Debug for _SOCKADDR_INET {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_SOCKADDR_INET {{ union }}")
    }
}
pub type SOCKADDR_INET = _SOCKADDR_INET;
pub const NL_ROUTE_PROTOCOL_RouteProtocolOther: NL_ROUTE_PROTOCOL = 1;
pub const NL_ROUTE_PROTOCOL_RouteProtocolLocal: NL_ROUTE_PROTOCOL = 2;
pub const NL_ROUTE_PROTOCOL_RouteProtocolNetMgmt: NL_ROUTE_PROTOCOL = 3;
pub const NL_ROUTE_PROTOCOL_RouteProtocolIcmp: NL_ROUTE_PROTOCOL = 4;
pub const NL_ROUTE_PROTOCOL_RouteProtocolEgp: NL_ROUTE_PROTOCOL = 5;
pub const NL_ROUTE_PROTOCOL_RouteProtocolGgp: NL_ROUTE_PROTOCOL = 6;
pub const NL_ROUTE_PROTOCOL_RouteProtocolHello: NL_ROUTE_PROTOCOL = 7;
pub const NL_ROUTE_PROTOCOL_RouteProtocolRip: NL_ROUTE_PROTOCOL = 8;
pub const NL_ROUTE_PROTOCOL_RouteProtocolIsIs: NL_ROUTE_PROTOCOL = 9;
pub const NL_ROUTE_PROTOCOL_RouteProtocolEsIs: NL_ROUTE_PROTOCOL = 10;
pub const NL_ROUTE_PROTOCOL_RouteProtocolCisco: NL_ROUTE_PROTOCOL = 11;
pub const NL_ROUTE_PROTOCOL_RouteProtocolBbn: NL_ROUTE_PROTOCOL = 12;
pub const NL_ROUTE_PROTOCOL_RouteProtocolOspf: NL_ROUTE_PROTOCOL = 13;
pub const NL_ROUTE_PROTOCOL_RouteProtocolBgp: NL_ROUTE_PROTOCOL = 14;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_OTHER: NL_ROUTE_PROTOCOL = 1;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_OTHER: NL_ROUTE_PROTOCOL = 1;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_LOCAL: NL_ROUTE_PROTOCOL = 2;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_LOCAL: NL_ROUTE_PROTOCOL = 2;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_NETMGMT: NL_ROUTE_PROTOCOL = 3;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_NETMGMT: NL_ROUTE_PROTOCOL = 3;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_ICMP: NL_ROUTE_PROTOCOL = 4;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_ICMP: NL_ROUTE_PROTOCOL = 4;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_EGP: NL_ROUTE_PROTOCOL = 5;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_EGP: NL_ROUTE_PROTOCOL = 5;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_GGP: NL_ROUTE_PROTOCOL = 6;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_GGP: NL_ROUTE_PROTOCOL = 6;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_HELLO: NL_ROUTE_PROTOCOL = 7;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_HELLO: NL_ROUTE_PROTOCOL = 7;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_RIP: NL_ROUTE_PROTOCOL = 8;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_RIP: NL_ROUTE_PROTOCOL = 8;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_IS_IS: NL_ROUTE_PROTOCOL = 9;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_IS_IS: NL_ROUTE_PROTOCOL = 9;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_ES_IS: NL_ROUTE_PROTOCOL = 10;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_ES_IS: NL_ROUTE_PROTOCOL = 10;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_CISCO: NL_ROUTE_PROTOCOL = 11;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_CISCO: NL_ROUTE_PROTOCOL = 11;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_BBN: NL_ROUTE_PROTOCOL = 12;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_BBN: NL_ROUTE_PROTOCOL = 12;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_OSPF: NL_ROUTE_PROTOCOL = 13;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_OSPF: NL_ROUTE_PROTOCOL = 13;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_BGP: NL_ROUTE_PROTOCOL = 14;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_BGP: NL_ROUTE_PROTOCOL = 14;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_NT_AUTOSTATIC: NL_ROUTE_PROTOCOL = 10002;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_NT_AUTOSTATIC: NL_ROUTE_PROTOCOL = 10002;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_NT_STATIC: NL_ROUTE_PROTOCOL = 10006;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_NT_STATIC: NL_ROUTE_PROTOCOL = 10006;
pub const NL_ROUTE_PROTOCOL_MIB_IPPROTO_NT_STATIC_NON_DOD: NL_ROUTE_PROTOCOL = 10007;
pub const NL_ROUTE_PROTOCOL_PROTO_IP_NT_STATIC_NON_DOD: NL_ROUTE_PROTOCOL = 10007;
pub type NL_ROUTE_PROTOCOL = u32;
pub const _NL_ROUTE_ORIGIN_NlroManual: _NL_ROUTE_ORIGIN = 0;
pub const _NL_ROUTE_ORIGIN_NlroWellKnown: _NL_ROUTE_ORIGIN = 1;
pub const _NL_ROUTE_ORIGIN_NlroDHCP: _NL_ROUTE_ORIGIN = 2;
pub const _NL_ROUTE_ORIGIN_NlroRouterAdvertisement: _NL_ROUTE_ORIGIN = 3;
pub const _NL_ROUTE_ORIGIN_Nlro6to4: _NL_ROUTE_ORIGIN = 4;
pub type _NL_ROUTE_ORIGIN = u32;
pub use self::_NL_ROUTE_ORIGIN as NL_ROUTE_ORIGIN;
pub type NET_IFINDEX = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NET_LUID {
    pub Value: ULONG64,
    pub Info: _NET_LUID__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NET_LUID__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
}
#[test]
fn bindgen_test_layout__NET_LUID__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NET_LUID__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_NET_LUID__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NET_LUID__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NET_LUID__bindgen_ty_1))
    );
}
impl _NET_LUID__bindgen_ty_1 {
    #[inline]
    pub fn Reserved(&self) -> ULONG64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn NetLuidIndex(&self) -> ULONG64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_NetLuidIndex(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn IfType(&self) -> ULONG64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_IfType(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved: ULONG64,
        NetLuidIndex: ULONG64,
        IfType: ULONG64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(24usize, 24u8, {
            let NetLuidIndex: u64 = unsafe { ::std::mem::transmute(NetLuidIndex) };
            NetLuidIndex as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let IfType: u64 = unsafe { ::std::mem::transmute(IfType) };
            IfType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__NET_LUID() {
    assert_eq!(
        ::std::mem::size_of::<_NET_LUID>(),
        8usize,
        concat!("Size of: ", stringify!(_NET_LUID))
    );
    assert_eq!(
        ::std::mem::align_of::<_NET_LUID>(),
        8usize,
        concat!("Alignment of ", stringify!(_NET_LUID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NET_LUID>())).Value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NET_LUID),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NET_LUID>())).Info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NET_LUID),
            "::",
            stringify!(Info)
        )
    );
}
impl ::std::fmt::Debug for _NET_LUID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_NET_LUID {{ union }}")
    }
}
pub type NET_LUID = _NET_LUID;
pub const _MIB_NOTIFICATION_TYPE_MibParameterNotification: _MIB_NOTIFICATION_TYPE = 0;
pub const _MIB_NOTIFICATION_TYPE_MibAddInstance: _MIB_NOTIFICATION_TYPE = 1;
pub const _MIB_NOTIFICATION_TYPE_MibDeleteInstance: _MIB_NOTIFICATION_TYPE = 2;
pub const _MIB_NOTIFICATION_TYPE_MibInitialNotification: _MIB_NOTIFICATION_TYPE = 3;
pub type _MIB_NOTIFICATION_TYPE = u32;
pub use self::_MIB_NOTIFICATION_TYPE as MIB_NOTIFICATION_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IP_ADDRESS_PREFIX {
    pub Prefix: SOCKADDR_INET,
    pub PrefixLength: UINT8,
}
#[test]
fn bindgen_test_layout__IP_ADDRESS_PREFIX() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADDRESS_PREFIX>(),
        32usize,
        concat!("Size of: ", stringify!(_IP_ADDRESS_PREFIX))
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADDRESS_PREFIX>(),
        4usize,
        concat!("Alignment of ", stringify!(_IP_ADDRESS_PREFIX))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IP_ADDRESS_PREFIX>())).Prefix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IP_ADDRESS_PREFIX),
            "::",
            stringify!(Prefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IP_ADDRESS_PREFIX>())).PrefixLength as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IP_ADDRESS_PREFIX),
            "::",
            stringify!(PrefixLength)
        )
    );
}
impl ::std::fmt::Debug for _IP_ADDRESS_PREFIX {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_IP_ADDRESS_PREFIX {{ Prefix: {:?}, PrefixLength: {:?} }}",
            self.Prefix, self.PrefixLength
        )
    }
}
pub type IP_ADDRESS_PREFIX = _IP_ADDRESS_PREFIX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MIB_IPFORWARD_ROW2 {
    pub InterfaceLuid: NET_LUID,
    pub InterfaceIndex: NET_IFINDEX,
    pub DestinationPrefix: IP_ADDRESS_PREFIX,
    pub NextHop: SOCKADDR_INET,
    pub SitePrefixLength: UCHAR,
    pub ValidLifetime: ULONG,
    pub PreferredLifetime: ULONG,
    pub Metric: ULONG,
    pub Protocol: NL_ROUTE_PROTOCOL,
    pub Loopback: BOOLEAN,
    pub AutoconfigureAddress: BOOLEAN,
    pub Publish: BOOLEAN,
    pub Immortal: BOOLEAN,
    pub Age: ULONG,
    pub Origin: NL_ROUTE_ORIGIN,
}
#[test]
fn bindgen_test_layout__MIB_IPFORWARD_ROW2() {
    assert_eq!(
        ::std::mem::size_of::<_MIB_IPFORWARD_ROW2>(),
        104usize,
        concat!("Size of: ", stringify!(_MIB_IPFORWARD_ROW2))
    );
    assert_eq!(
        ::std::mem::align_of::<_MIB_IPFORWARD_ROW2>(),
        8usize,
        concat!("Alignment of ", stringify!(_MIB_IPFORWARD_ROW2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MIB_IPFORWARD_ROW2>())).InterfaceLuid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MIB_IPFORWARD_ROW2),
            "::",
            stringify!(InterfaceLuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MIB_IPFORWARD_ROW2>())).InterfaceIndex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MIB_IPFORWARD_ROW2),
            "::",
            stringify!(InterfaceIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MIB_IPFORWARD_ROW2>())).DestinationPrefix as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MIB_IPFORWARD_ROW2),
            "::",
            stringify!(DestinationPrefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MIB_IPFORWARD_ROW2>())).NextHop as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MIB_IPFORWARD_ROW2),
            "::",
            stringify!(NextHop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MIB_IPFORWARD_ROW2>())).SitePrefixLength as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_MIB_IPFORWARD_ROW2),
            "::",
            stringify!(SitePrefixLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MIB_IPFORWARD_ROW2>())).ValidLifetime as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_MIB_IPFORWARD_ROW2),
            "::",
            stringify!(ValidLifetime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MIB_IPFORWARD_ROW2>())).PreferredLifetime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_MIB_IPFORWARD_ROW2),
            "::",
            stringify!(PreferredLifetime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MIB_IPFORWARD_ROW2>())).Metric as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_MIB_IPFORWARD_ROW2),
            "::",
            stringify!(Metric)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MIB_IPFORWARD_ROW2>())).Protocol as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_MIB_IPFORWARD_ROW2),
            "::",
            stringify!(Protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MIB_IPFORWARD_ROW2>())).Loopback as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_MIB_IPFORWARD_ROW2),
            "::",
            stringify!(Loopback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MIB_IPFORWARD_ROW2>())).AutoconfigureAddress as *const _
                as usize
        },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(_MIB_IPFORWARD_ROW2),
            "::",
            stringify!(AutoconfigureAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MIB_IPFORWARD_ROW2>())).Publish as *const _ as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(_MIB_IPFORWARD_ROW2),
            "::",
            stringify!(Publish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MIB_IPFORWARD_ROW2>())).Immortal as *const _ as usize },
        95usize,
        concat!(
            "Offset of field: ",
            stringify!(_MIB_IPFORWARD_ROW2),
            "::",
            stringify!(Immortal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MIB_IPFORWARD_ROW2>())).Age as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_MIB_IPFORWARD_ROW2),
            "::",
            stringify!(Age)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MIB_IPFORWARD_ROW2>())).Origin as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_MIB_IPFORWARD_ROW2),
            "::",
            stringify!(Origin)
        )
    );
}
impl ::std::fmt::Debug for _MIB_IPFORWARD_ROW2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "_MIB_IPFORWARD_ROW2 {{ InterfaceLuid: {:?}, InterfaceIndex: {:?}, DestinationPrefix: {:?}, NextHop: {:?}, SitePrefixLength: {:?}, ValidLifetime: {:?}, PreferredLifetime: {:?}, Metric: {:?}, Protocol: {:?}, Loopback: {:?}, AutoconfigureAddress: {:?}, Publish: {:?}, Immortal: {:?}, Age: {:?}, Origin: {:?} }}" , self . InterfaceLuid , self . InterfaceIndex , self . DestinationPrefix , self . NextHop , self . SitePrefixLength , self . ValidLifetime , self . PreferredLifetime , self . Metric , self . Protocol , self . Loopback , self . AutoconfigureAddress , self . Publish , self . Immortal , self . Age , self . Origin )
    }
}
pub type MIB_IPFORWARD_ROW2 = _MIB_IPFORWARD_ROW2;
pub type PMIB_IPFORWARD_ROW2 = *mut _MIB_IPFORWARD_ROW2;
pub type PIPFORWARD_CHANGE_CALLBACK = ::std::option::Option<
    unsafe extern "stdcall" fn(
        CallerContext: PVOID,
        Row: PMIB_IPFORWARD_ROW2,
        NotificationType: MIB_NOTIFICATION_TYPE,
    ),
>;
extern "stdcall" {
    pub fn NotifyRouteChange2(
        AddressFamily: ADDRESS_FAMILY,
        Callback: PIPFORWARD_CHANGE_CALLBACK,
        CallerContext: PVOID,
        InitialNotification: BOOLEAN,
        NotificationHandle: *mut HANDLE,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn CancelMibChangeNotify2(NotificationHandle: HANDLE) -> NTSTATUS;
}
